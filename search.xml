<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[android adb 常用命令收集]]></title>
      <url>http://ethanwanggg.github.io/2016/07/07/android-adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<hr>
<p><code>adb start-server</code><br>启动adb服务,如果它没启动的话</p>
<h3 id="adb-kill-server"><a href="#adb-kill-server" class="headerlink" title="adb kill-server"></a>adb kill-server</h3><p>关闭服务</p>
<ul>
<li>adb devices<br>查看所连接的设备以及设备所对应的序列号</li>
<li>adb install -r xxxx.apk<br>安装app,需要注意的是如果连接了两台设备,则会报错,此时可以添加-s <serialnumber>来处理</serialnumber></li>
<li>adb uninstall packagename<br>卸载app,有时候在手机上卸载App会出现数据清理不干净,导致App再也装不上了,这个时候可以敲命令来卸载</li>
<li>adb shell<br>进入shell环境</li>
<li>adb shell pm clear packagename<br>清除应用的数据,很常用吧?</li>
<li>adb shell am start -n packagename/packagename.activityname<br>启动某个应用的某个Activity(以前调试老年机,那种Launcher上没有APP的机器,全靠它啊!!!!!!!)</li>
<li>adb connect <device-ip-address><br>连接到指定的ip,这个通常配合wifidebug</device-ip-address></li>
<li>adb shell dumpsys activity top<br>查看栈顶Activity,可以用来获取包名,可以用来查看其它app的包名</li>
<li>adb shell ps<br>查看进程信息</li>
<li>adb shell pm list packages -f<br>查看所有已安装的应用的包名</li>
<li>adb shell dumpsys activity<br>dumpsys系列命令可以帮助我们查看各种信息<br>am的状态 Activity Manager State</li>
<li>adb shell dumpsys package<br>包信息 Package Information</li>
<li>adb shell dumpsys meminfo<br>内存使用情况Memory Usage</li>
<li>adb pull <remote> <local><br>从手机复制文件出来,比如把Crash日志写在SD卡上,再pull到电脑上 或者 pull ANR的trace日志</local></remote></li>
<li>adb push <local> <remote><br>向手机发送文件,比如测试热修复补丁~<br>eg. adb push foo.txt /sdcard/foo.txt</remote></local></li>
<li>adb shell cat /proc/cpuinfo<br>查看手机CPU,可以看到手机架构(eg.ARMv7) 和几核处理器<br>可以帮助我们选择so库,排查手机cpu架构相关的问题</li>
<li>adb shell df<br>获取手机磁盘空间</li>
<li>adb shell getprop ro.build.version.release<br>获取手机系统版本</li>
<li>adb shell dumpsys procstats<br>Memory Use Over Time</li>
<li>adb shell dumpsys gfxinfo<br>Graphics State</li>
<li>adb version<br>查看adb版本</li>
<li>adb help<br>进入adb帮助界面</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈设计模式]]></title>
      <url>http://ethanwanggg.github.io/2016/06/16/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>从学习软件开发开始，我们一直在讨论的就是程序设计模式。常用的有<strong>MVC</strong> 、<strong>MVP</strong> 、<strong>MVVM</strong> ，今天想把这几个模式拿出来说一说。</p>
<h1 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1.MVC:"></a>1.MVC:</h1><ul>
<li>模型（Model）：数据存储传递</li>
<li>视图（View）：界面UI部分</li>
<li>控制器（Controller）：</li>
</ul>
<blockquote>
<p>执行流程：<br>1.View与用户交互，将动作传递给Controller<br>2.Controller调用Model进行数据请求<br>3.服务端返回处理结果后，Model通知View<br>4.View进行画面处理</p>
</blockquote>
<p> 缺点：Controller不知道任何View的细节，一个Controller能被多个View使用，很难对Controller进行单元测试，Controller操作数据，但是如何从View上断言这些数据的变化呢？</p>
<p><img src="/images/浅谈设计模式/MVC.png" alt="MVC" title="MVC"></p>
<h1 id="2-MVP"><a href="#2-MVP" class="headerlink" title="2.MVP:"></a>2.MVP:</h1><p>MVP模式中将Controller 替换为Presenter，彻底的分离了View 与Model 的关联。Presenter 做业务逻辑，View 与 Model 不发生联系，都通过 Presenter 传递。</p>
<blockquote>
<p>执行流程<br>1.View与用户交互，将动作转交给Presenter。<br>2.Presenter操作Model进行数据请求。<br>3.Model通知Presenter数据变化。<br>4.Presenter更新View的变化。</p>
</blockquote>
<p>优点：<br>1.模型与视图的彻底分离，修改视图不再影响模型。<br>2.Presenter可应用于多个视图。<br>3.方便协作，UI与后台借口测试互不干涉</p>
<p>缺点：<br>1.类数量爆炸，代码复杂学习成本高。<br>2.视图的渲染在Presenter中，Presenter与视图的关系过于紧密，可能导致视图变化连带着Presenter也要变化。</p>
<p><img src="/images/浅谈设计模式/MVP.png" alt="MVP" title="MVP"></p>
<h1 id="3-MVVM"><a href="#3-MVVM" class="headerlink" title="3.MVVM:"></a>3.MVVM:</h1><p>MVVM是在Model的基础上添加一个ViewModel，这个ViewModel除了正常的属性意外，还包括一些供View显示用的属性。Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致，只是将Presenter 与View 调整为了双向绑定。</p>
<p><img src="/images/浅谈设计模式/MVVM.png" alt="MVVM" title="MVVM"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客开张咯]]></title>
      <url>http://ethanwanggg.github.io/2016/05/19/hello-world/</url>
      <content type="html"><![CDATA[<p>一直有写博客的想法，百般折腾，终于在今天开通了！</p>
]]></content>
    </entry>
    
  
  
</search>
